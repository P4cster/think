
# üìÑ `INDEX()`

Die gute alte `INDEX`. In Verbindung mit `MATCH` eine unglaublich starke Verbindung, die auch an vielen Stellen verwendet wird. Zur Zeit ist die Kombination aufgrund des starken Wandels von Excel auf dem R√ºckgang, aber nach wie vor wunderbar zu verwenden, da sie auch nativ mit Arrays arbeiten kann.

Wenn es darum geht Werte aus einer Tabelle dynamisch zu finden und Suchmaschinen um eine L√∂sung bem√ºht, landet man in der Regel bei der `INDEX(MATCH())`-Kombination.

Die `INDEX`-Funktion kann ebenfalls als Referenz √ºbergeben werden. Bedeutet:
Anstelle von `A1:B10` k√∂nnte man auch `INDEX(A:A,1):INDEX(B:B,10)` schreiben. Das Ergebnis w√§re das selbe. Ist jetzt in diesem Beispiel vielleicht nicht sonderlich ersichtlich, aber durch diese Referenzierungsm√∂glichkeit, gibt die `INDEX`-Funktion vollkommene dynamische Kontrolle der Bereichsauswahl in die H√§nde des Anwenders. Weitere Funktionen, die von dieser Bereichsgeneratorfunktion profitieren sind `OFFSET` und `INDIREKT`.

## üîπ Syntax
`=INDEX(array, row_num, [col_num])`
`=INDEX(reference, row_num, [col_num], [area_num])`

### Parameter

| Parameter  | Beschreibung                                                     | Pflichtangabe | erwarteter Datentyp   |
| ---------- | ---------------------------------------------------------------- | ------------- | --------------------- |
| array      | zusammenh√§ngender Bereich, der durchsucht werden soll            | Ja            | Zelle, Bereich, Array |
| row_num    | numerischer Wert, der die Position der Reihe angibt               | Ja            | Zahl                  |
| \[col_num] | numerischer Wert, der die Position der Spalte angibt (Default: 1) | Nein          | Zahl                  |

| Parameter   | Beschreibung                                                 | Pflichtangabe | erwarteter Datentyp   |
| ----------- | ------------------------------------------------------------ | ------------- | --------------------- |
| reference   | getrennter Bereich, der durchsucht werden soll               | Ja            | Zelle, Bereich, Array |
| \[area_num] | numerischer Wert, der die Bereichsnummer angibt (Default: 1) | Nein          | Zahl                  |


## üîç In einfacher Sprache
*Was macht diese Funktion eigentlich ‚Äì ohne Fachchinesisch?*

Ich verweise hier auf die Funktionsweise der schon besprochenen `VLOOKUP`, da die der `INDEX` √§hnlich ist. Die `INDEX` fragt dabei allerdings nicht "wie weit es suchen soll", sondern eher direkt nach den Koordinaten. 
Array-Schreibweise:
Bleiben wir bei dem Beispiel mit unserem Regal, dann w√§re die Frage von `INDEX` ein einfaches "In welchem Bereich soll ich wo suchen?". Antwort: "Regal 2, Reihe 4, Spalte 2."

Referenz-Schreibweise:
Wenn wir nun aber nicht nur ein Regal, sondern ein ganzes Lager haben, m√ºssten wir rein theoretisch tausende einzelne Indexabfragen schreiben, um alle Lagerpl√§tze abdecken zu k√∂nnen. Hier kommt die Referenzschreibweise ins Spiel, die mit den beiden Parametern *reference* und *area_num* aufwartet. Mit dieser k√∂nnen wir der `INDEX`-Funktion direkt alle m√∂glichen Regale √ºbergeben und sagen ihm am Ende nur in welchem aller √ºbergebenen Regale er suchen soll. Wie sich die Schreibweisen jeweils unterscheiden wird gleich deutlich.

## üìå Wof√ºr ist das n√ºtzlich?
- Alles. No joke. Die `INDEX`-Funktion ist eine der versatilsten Formeln, die es schon seit √Ñonen von Jahren gibt und nicht umsonst eine der popul√§rsten ist.
- Insbesondere die M√∂glichkeit `INDEX` als Bereichsgenerator zu √ºbergeben macht sie besonders stark. Wissen nur sehr wenige.
- Dynamische R√ºckgabe von Bereichen
- Verwalten mehrerer Bereiche √ºber eine einzige Formel
- Ansprechen der einzelnen Parameter sehr simpel
- kann √ºber `SEQUENCE` ganze Bereiche automatisiert und sehr kompakt abrufen

## üî¢ Beispiel
```excel
# Array-Schreibweise
## normale Index-Abfrage
=INDEX(A1:B10, 2, 2) --> zeigt den Inhalt von B2

=INDEX(C3:F15, 6, 3) --> zeigt den Inhalt von E9

=INDEX(A:A, 6) --> zeigt den Inhalt von A6 (Column defaults to 1)

## Index als Bereichsgenerator
=INDEX(A:A, 6):INDEX(C:C, 9) --> referenziert den Bereich A6:C9

=D1:INDEX(F:F, 18) --> referenziert den Bereich D1:F18
```

Die Referenz-Schreibweise bedarf etwas mehr Erkl√§rung, da sie nicht direkt so intuitiv ist, wie die Array-Schreibweise.
Prinzipiell machen beide Schreibweisen das selbe. Sie geben entweder einen Zellinhalt/Bereichsinhalt, oder eine Referenz zur√ºck. Der Unterschied zwischen beiden Schreibweisen liegt aber eigentlich "nur" darin, dass der Referenzschreibweise mehrere Bereiche √ºbergeben werden k√∂nnen. Der Array-Schreibweise jedoch nur ein zusammenh√§ngender.

Die verschiedenen Bereiche werden innerhalb der `INDEX` von Klammern umgeben. Danach kommt, wie gewohnt, Zeilennummer, danach, wie gewohnt, Spaltennummer. Als vierten Parameter k√∂nnen wir nun eine *area_num* √ºbergeben. Diese Zahl ist letztlich nichts anderes als ein "Ich habe dir 5 Regale zur Verf√ºgung gestellt (*reference*-Parameter in Klammern). Suche bitte nun im 2. Regal (*area_num*=2), in der 5. Reihe (*row_num*) und der 6. Spalte (*col_num*)." 

```excel
## Index in der Referenzschreibweise
=INDEX((A1:C15, D3:E18, F7:F19), 1, 2, 1) --> gibt den Wert in B1 zur√ºck

=INDEX((A:A, B:B, C:C), 1, 1, 1) --> gibt den Wert in A1 zur√ºck
```

Schl√ºsseln wir das ganze ein wenig auf, auch wenn es so langsam schon etwas deutlicher werden sollte. Wir nehmen uns das zweite Beispiel aus dem Codeblock.

`=INDEX((A:A, B:B, C:C), 1, 1, 1)`
Hier werden drei Bereiche √ºbergeben:
1. A:A
2. B:B
3. C:C
Im Anschluss sagen wir, dass wir in der ersten Reihe (*row_num*= erste Eins) und in der ersten Spalte (*col_num*=zweite Eins) suchen m√∂chten. Nun hat Excel bzw. die `INDEX`-Funktion allerdings drei Bereiche, in denen es suchen kann. Dementsprechend m√ºssen wir nun nur noch mitteilen, dass wir im ersten Bereich A:A (*area_num*=dritte Eins) suchen m√∂chten. W√ºrden wir anstelle einer `1` eine `2` dort eintragen, w√ºrde der Bereich B:B durchsucht werden.

## üí° Kreativer Einsatz
*Wie l√§sst sich die Funktion clever kombinieren oder zweckentfremden?*
- Kombination mit `MATCH`, `XMATCH`, `SEARCH`, `OFFSET`. `INDIRECT`, `SEQUENCE`, etc.
- In einfachen Excelmodellen kann `INDEX`ein wenig wie ein Leuchtturm fungieren

## ‚ö† Typische Fehlerquellen
- \#REF! - der gesuchte Bereich ist nicht vorhanden
	- kommt dann vor, wenn man zwei Spalten angibt, aber in einer dritten suchen m√∂chte
- \#VALUE bei falscher Kombination von Datentypen
- typischer Denkfehler: Verwechselung von Reihen- und Spaltenangaben

## üß† Denkstruktur hinter der Funktion
*Wie funktioniert diese Funktion auf struktureller Ebene?*
So langsam kommen wir in den Bereich von Modelllogik. Wenn man die `INDEX`-Formel elegant verwendet, dann kann man jeden einzelnen Parameter von ihr dynamisch anpassen und durch Benutzereingaben manipulierbar machen. Wir haben hier eine Formel, die viele schon kennen, aber nichtmals im Ansatz wissen, zu was sie f√§hig ist.

___


# üìÑ `MATCH()`

## üîπ Syntax
`=MATCH(lookup_value; lookup_array; [match_type])`

### Parameter

| Parameter     | Beschreibung                           | Pflichtangabe | erwarteter Datentyp   |
| ------------- | -------------------------------------- | ------------- | --------------------- |
| lookup_value  | Wert, der gesucht werden soll          | Ja            | Text, Zahl, Array     |
| lookup_array  | Bereich, in dem gesucht werden soll    | Ja            | Zelle, Bereich, Array |
| \[match_type] | Wie soll gesucht werden? Defaults to 0 | Nein          | 1, 0, -1              |

- \[match_type]:
	- 1 - Less than - Findet entweder genau, oder den n√§chst kleineren Eintrag
	- 0 - Exact match - Findet genau den Eintrag
	- -1 - Greater than - Findet entweder genau, oder den n√§chst gr√∂√üeren Eintrag

### WICHTIG!
Der Parameter *lookup_array* ist stark fehlleitend. W√§hrend andere Formeln das Wort Array auch f√ºr einen zweidimensionalen Bereich verwenden, ist hier nur ein eindimensionaler Bereich gemeint. Also entweder: innerhalb einer Reihe oder innerhalb einer Spalte. Falls man einen zweidimensionalen Bereich angibt, gibt die Formel direkt einen \#N/A-Fehler zur√ºck.

Um mit *match_type*=1 oder -1 suchen zu k√∂nnen, m√ºssen die Daten auch einer logisch aufsteigenden/absteigenden Sortierung folgen. Also von der kleinsten zur gr√∂√üten Nummer, oder umgekehrt. Hier ist nochmal zu erw√§hnen, dass es f√ºr *approximate match* es bezogen auf Text bessere Funktionen wie die `SEARCH` oder `FIND` gibt. 
Nichtsdestotrotz eignet sich die `MATCH` hervorragend f√ºr die Suche eines *exact match* im Rahmen von Tabellen√ºberschriften o√§, da sie nicht auf Gro√ü- oder Kleinschreibung achtet.

## üîç In einfacher Sprache
*Was macht diese Funktion eigentlich ‚Äì ohne Fachchinesisch?*
Die `MATCH`, ebenso wie ihr "kleiner" Bruder `XMATCH`, sind Funktionen, die insbesondere f√ºr Suchen, bzw. Vergleiche, konzipiert wurden. Wenn wir bei Funktionen wie `INDEX` oder `VLOOKUP` noch explizit angeben mussten WO gesucht werden soll (Koordinatensystem), k√∂nnen wir der `MATCH`-Funktion einfach nur sagen, WAS wir suchen. Und uns wird eine passende Position ausgespuckt.

Warum ist das jetzt so ein Gamechanger?
Nun, bleiben wir bei dem direkten Anwendungsfall der `INDEX(MATCH))`-Kombination. `INDEX` erwartet als √úbergabeparameter f√ºr *row_num* und *col_num* Zahlen. Und was gibt uns die `MATCH`? Richtig. Zahlen. Aber nicht irgendwelche Zahlen, sondern die genaue Position eines gesuchten Begriffs, oder Werts. Und hier wird nun auch bewusst, weshalb die beiden Funktionen in Kombination eine solch enorme Ber√ºmtheit erringen konnten. Mit diesen beiden, durchaus einfachen, Funktionen, hat man die M√∂glichkeit einen riesigen zweidimensionalen Bereich zu durchsuchen, ohne sich totzuformeln.

## üìå Wof√ºr ist das n√ºtzlich?
- Gro√üe Bereiche werden greif- und durchsuchbar
	- wir sprechen hier nicht von 100er, sondern eher von 1.000er und 10.000er Dimensionen
- Popularit√§t - klingt komisch, sie ist aber in Verbindung mit `INDEX` so stark verbreitet, dass man sie selten erkl√§ren muss
- kann als alleinstehende Funktion auch als erste Anlaufstelle f√ºr Orientierung verwendet werden

## üî¢ Beispiel
```excel
=MATCH("test", A1:F1) --> sucht nach dem exakten Wort "test" in Reihe 1 und gibt dessen Position zur√ºck

=MATCH("Peter", A2:A200) --> sucht nach dem exakten Wort "Peter" in Spalte A und gibt dessen Position zur√ºck

=MATCH(15, A1:A200, 1) --> sucht nach dem Wert 15 im angegebenen Bereich. Wird 15 nicht gefunden, sucht er nach der 14, also dem n√§chst kleineren, usw.

=MATCH(15, A1:F1, -1) --> sucht nach dem Wert 15 im angegebenen Bereich. Wird 15 nicht gefunden, sucht er nach 16, also dem n√§chst gr√∂√üeren, usw.
```

## üìä Was kommt dabei raus?
| Eingabe-Daten          | Ergebnis der Funktion                   |
| ---------------------- | --------------------------------------- |
| =MATCH("test", A1:F1)  | ("test" in E1) 5                        |
| =MATCH(15, A1:A200, 1) | (15 nicht vorhanden, aber 13 in A10) 10 |

## üí° Kreativer Einsatz
*Wie l√§sst sich die Funktion clever kombinieren oder zweckentfremden?*
- Nicht unbedingt eine "clevere" Kombination im Sinne "Um die Ecke denken", aber dennoch explizit erw√§hnenswert: Die Suche nach Datum/Zeitangaben. Insbesondere hier zeigt sich die St√§rke der *match_type* Parameter, da wir mit einer `1`, also "Less than"-Suche, etwaige Reports, etc. immer auf dem aktuellsten Stand halten k√∂nnen.
- In Kombination mit iterierenden Funktionen (`MAP`, `REDUCE`, etc.) und der `INDIRECT` bietet die `INDEX(MATCH())`-Kombination ein wunderbares Werkzeug, um verschiedene Tabellenbl√§tter mit nur einer Formel zu durchsuchen.

## ‚ö† Typische Fehlerquellen
- \#N/A - entweder kein Wert gefunden, oder mehrdimensionaler Bereich √ºbergeben
- unlogische Ausgabe - approximate match und Bereich nicht sortiert
	- falls diese beiden passen, auch mal √ºberpr√ºfen, ob der Wert √∂fter als ein mal im angegebenen Bereich vorkommt. `MATCH` gibt immer nur das erste Vorkommen zur√ºck.

## üß† Denkstruktur hinter der Funktion
*Wie funktioniert diese Funktion auf struktureller Ebene?*
- Innerhalb der `INDEX(MATCH())`, kann man den Suchparameter der `MATCH` auf eine Zelle setzen und dadurch mit Benutzereingaben arbeiten.
